#重新认识Java泛型

##泛型的前奏
###JDK1.4及之前的黑暗时期
原生态类型，Object进行类型转化

比如往list中可以添加任何类型的对象，但是在从集合中获取对象时，无法确定获取到的对象是什么具体的类型

###为什么要引入泛型

1. 带来了类型安全性：
在编译器发现类型异常，静态语言  
提高代码表达力：比如方法返回泛型类型，智能推断

2. 能用Object的场景都可以用泛型替代，比如泛型T t，这个t能调用的都是Obejct里有的方法，默认看作是Obejct。

###什么时候需要重新用回原生态类型
1. 类class对象，比如 List.class 可以； List<<Integer>>.class 错误


##泛型的基础理论

###大部分编译器处理泛型的方式有

**方式一：**Code specialization。在实例化一个泛型类或泛型方法时都产生一份新的目标代码（字节码or二进制代码）。例如，针对一个泛型list，可能需要 针对string，integer，float产生三份目标代码。

**方式二：**Code sharing。对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换。

###Java编译器的处理方式
Code specialization实现会导致代码膨胀（code bloat），在引用类型系统中，浪费空间，因为引用类型集合中元素本质上都是一个指针，没必要为每个类型都产生一份执行代码。

所以Java编译器采用了方式二Code sharing，通过类型擦除（type erasue）来实现，即类型擦除是编译器对Java泛型的处理过程

###类型擦除
历史包袱：因为泛型是在1.5引入的，为了向前兼容，所以sun工程师们考虑只在编译时处理，同时使用桥接方法

从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。

类型擦除的处理过程如下：

1. 将所有的泛型参数用其最顶级的父类型替换（extends 的限定类型／Object）
2. 移除所有的类型参数信息，即去掉<>里的内容
3. 在必要的时候添加类型检查和类型转换的方法
4. 生成一些桥接方法（bridge method）


###桥接方法
类型擦除会带来两个问题

1. 类型擦除与多态的冲突
2. 方法签名冲突

桥接方法就是为了解决上述问题

###为什么要引入泛型通配符
实现协变，List<?> 等效于 List<? extends Object>

List<?> 可具体化的类型

举个例子

* Set<Object>是参数化类型，表示可以包含任何对象类型的一个集合
* Set<?>表示只能包含某种未知对象类型的一个集合
* Set原生类型是类型不安全的

###什么是协变，逆变和不变

逆变与协变用来描述类型转换（type transformation）后的继承关系，f(⋅)f(⋅)表示类型转换，≤表示继承关系

f(⋅)f(⋅)是协变（covariant）的，当A≤BA≤B时有f(A)≤f(B)成立f(A)≤f(B)成立

f(⋅)f(⋅)是逆变（contravariant）的，当A≤BA≤B时有f(B)≤f(A)f(B)≤f(A)成立

f(⋅)f(⋅)是不变（invariant）的，当A≤BA≤B时上述两个式子均不成立，即f(A)f(A)与f(B)f(B)相互之间没有继承关系

Java数组支持协变，Java的泛型不支持协变，但是可以通过通配符进行模拟

###泛型的上下边界

<? extends 限定类型> 类型实参只准传入某种类型的子类

<? super 限定类型> 类型实参只准传入某种类型的父类

<? extends 限定类型>实现了泛型的协变 
 
```
List<? extends Number> list = new ArrayList<Integer>();
```

<? super>实现了泛型的逆变

```
List<? super Number> list = new ArrayList<Object>();
```

###边界的副作用
那就是容器的部分功能可能失效

###PECS原则
producer extends, consumer super


##泛型的使用场景

###数组和泛型

数组是具体化的，即在运行时才知道并检查他们的元素类型；泛型是在编译器就检查他们的元素类型

####为什么数组不支持泛型元素
1. 数组是协变和可具体化，提供运行时类型安全，没有编译时类型安全
2. 泛型不支持协变，类型擦除，提供编译时类型安全

上述1和2点逻辑是矛盾的，所以数组不支持泛型元素，当需要数组和泛型混合使用，使用列表来实现(Effective Java 第25条 列表优于数组)

###泛型类
在实例化类的时候指明泛型的具体类型

###泛型接口

###泛型方法
是在调用方法的时候指明泛型的具体类型

泛型类里带泛型方法

泛型声明，泛型使用

泛型方法能使方法独立于类而产生变化


##泛型的使用思维

1. 泛型是用来传递对象类型，像从管道里滑一遍出来
2. 在封装的时候，我们不知道泛型实参类型，因此无法使用对应的方法
3. 泛型能规整参数的类型的位置关系


###泛型涉及到的Java概念汇总
**原生态类型**

**类型形参**

**类型实参**

**协变** （kotlin语言文档翻译为型变）
**逆变**
**不变**

**通配符**

**泛型上边界**

**泛型下边界**

**类型安全:** 在运行时不发生ClassCastException异常

**可具体化类型(reifiable):** 其运行时表示法包含的信息比编译时表示法包含更多的信息的类型

**不可具体化的类型（non-reifiable）:** 其运行时表示法包含的信息比它的编译时表示法包含更少的信息的类型


##参阅文章

[知乎：Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)

[java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一](http://blog.csdn.net/s10461/article/details/53941091)

[Java泛型－类型擦除](http://blog.csdn.net/caihaijiang/article/details/6403349)

[第六节：协变和逆变](http://swiftlet.net/archives/1950)

[Java中的逆变与协变](https://www.cnblogs.com/en-heng/p/5041124.html)

[Java系列：关于Java中的桥接方法](https://www.cnblogs.com/strinkbug/p/5019453.html)

[Java泛型2---泛型的本质 ](http://blog.sina.com.cn/s/blog_44c1e6da0100coxb.html)
